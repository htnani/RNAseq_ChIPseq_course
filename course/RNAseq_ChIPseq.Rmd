---
title: "RNA-seq and ChIP-seq"
author: "Pascal"
date: "14 octobre 2018"
output: html_document
bibliography: RNAseqChIPseq.bibtex
csl: cell.csl
highlight: github
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(kableExtra)
```

## Data and session setup  

_In this document, the commands corresponding to module loading are intended to be run on the genologin cluster (see [bioinformatic platform](http://bioinfo.genotoul.fr/))_  
_Alternatively, install individual tools (links provided in this document) or use [bioconda](https://bioconda.github.io/)_


### Data presentation 

The data analyzed here come from [GSE70408](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE70408) [@pmid26279188].  
  
Transcription by __RNA polymerase II__ (RNAPII) involves several steps:  

* Promoter opening under the effect of __transcription factors__ (TFs) and their __cofactors__ (chromatin modifiers and remodelers, mediator)  
* Assembly of the __preinitiation complex__ (PIC)  
* Promoter __escape__  
* For a large fraction of metazoan genes: __Promoter-proximal pausing__ of RNAPII  
* Productive __elongation__  
* Transcription __termination__  
* At least in certain cases RNAPII __recycling__  
  
The article describes the role of the __transcription elongation factor PAF1__ on RNAPII promoter-proximal pausing. The authors use different genome-wide approaches in Human and Drosophila cells to study the location of PAF1 and the effect of its knock-down on RNAPII distribution and RNA expression.  

Here, we focus on the RNA-seq data and some of the ChIP-seq data produced in the article. In order to keep computations at an acceptable level, we will only keep chromosomes 19 and 20 which cover ~120Mb (comparable to the size of  Drosophila melanogaster or Arabidopsis thaliana whole genome).  
  

### Session setup  

Prepare the folders in which the analysis will be performed:
```{bash eval=FALSE}
basedir="/work/pmartin/PROJECTS/RNAseqChIPseq"
# replace pmartin by your username if you work on GenoToul cluster

mkdir ${basedir}/RNAseq
mkdir ${basedir}/ChIPseq
mkdir ${basedir}/bank
mkdir ${basedir}/log

selectedChromosomes="chr19 chr20"
```
  
  

### Sequences, annotations and indexes  

The genome sequences and annotations are downloaded from [Gencode](https://www.gencodegenes.org/).  

#### Genome sequence (fasta)  

Download the whole genome sequence:
```{bash eval=FALSE}
cd ${basedir}/bank
wget ftp://ftp.ebi.ac.uk/pub/databases/gencode/Gencode_human/release_28/GRCh38.primary_assembly.genome.fa.gz
gunzip GRCh38.primary_assembly.genome.fa.gz
```

Then:  

* index the fasta file with [samtools](http://www.htslib.org/)  
* extract the sequences of chr19 and chr20 an index  
* delete the large fasta file containing the whole genome sequence  
```{bash eval=FALSE}
cd ${basedir}/bank
module load bioinfo/samtools-1.8 #on genologin cluster
samtools index GRCh38.primary_assembly.genome.fa
samtools faidx GRCh38.primary_assembly.genome.fa ${selectedChromosomes} > GRCh38.primary_assembly.chr1920.fa
samtools index GRCh38.primary_assembly.chr1920.fa
rm GRCh38.primary_assembly.genome.fa
```
  
  

#### Annotations (GTF file):  

We download the annotations:
```{bash eval=FALSE}
cd ${basedir}/bank
wget ftp://ftp.ebi.ac.uk/pub/databases/gencode/Gencode_human/release_28/gencode.v28.annotation.gtf.gz
gunzip gencode.v28.annotation.gtf.gz

```
  
And select the annotations from chr19 and chr20 only:
```{bash eval=FALSE}
awk '$1 ~ /^##.+/ || $1=="chr19"|| $1=="chr20"' \
gencode.v28.annotation.gtf \
> \
gencode.v28.annotation_chr1920.gtf

#Cleanup
rm gencode.v28.annotation.gtf
```
  
  
#### STAR index:  

[STAR](https://github.com/alexdobin/STAR) is a powerful short read aligner dedicated to RNA-seq [@pmid23104886].
While a very fast aligner, it requires relatively large amounts of RAM.  
[HiSat2](https://ccb.jhu.edu/software/hisat2/index.shtml) is a popular alternative [@pmid27560171; @pmid25751142]

Before running alignments with STAR, we need to generate genome indexes:
```{bash eval=FALSE}
mkdir ${basedir}/bank/star_index
module load bioinfo/STAR-2.6.0c #on genologin cluster

STAR \
--runThreadN 4 \
--runMode genomeGenerate \
--genomeDir ${basedir}/bank/star_index \
--genomeFastaFiles ${basedir}/bank/GRCh38.primary_assembly.chr1920.fa \
--sjdbGTFfile ${basedir}/bank/gencode.v28.annotation_chr1920.gtf \

```

#### Bowtie2 index:  

Popular short read aligners include [Bowtie2](http://bowtie-bio.sourceforge.net/bowtie2) [@pmid22388286] and [bwa](http://bio-bwa.sourceforge.net/) [@pmid19451168; @pmid20080505].  

We use bowtie2 here and build the genome index using:  
```{bash eval=FALSE}
mkdir ${basedir}/bank/bowtie2_index
module load bioinfo/bowtie2-2.3.4.1 #on genologin cluster

bowtie2-build \
--threads 4 \
--seed 123 \
${basedir}/bank/GRCh38.primary_assembly.chr1920.fa \
${basedir}/bank/bowtie2_index/GRCh38.primary_assembly.chr1920 \

```

  

#### Transcripts sequences:  

Some recent so-called "alignment-free" methods such as [kallisto](https://pachterlab.github.io/kallisto/) [@pmid27043002] and [Salmon](https://combine-lab.github.io/salmon/) [@pmid28263959] do not perform a classical alignment of reads on the genome prior to assigning reads to genomic features (genes/transcripts). Rather, they rely on matching catalogs of k-mers obtained from the transcriptome on one hand and the reads on the other hands.  
  
For these methods, we need the sequences of all transcripts:
```{bash eval =FALSE}
cd ${basedir}/bank
wget ftp://ftp.ebi.ac.uk/pub/databases/gencode/Gencode_human/release_28/gencode.v28.transcripts.fa.gz
```
  
  
### Raw data (reads)  

The [EBI European Nucleotide Archive](https://www.ebi.ac.uk/ena) is a convenient way to access NGS data. In particular, it includes a copy of the [NCBI Short Read archive](https://www.ncbi.nlm.nih.gov/sra).  

Individual fastq files can be downloaded, such as:
```{bash eval=FALSE}
wget ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR208/008/SRR2084598/SRR2084598.fastq.gz
wget ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR208/009/SRR2084599/SRR2084599.fastq.gz
```
  
We can also download the SRA file (lighter) and then extract the fastq file using the [SRA toolkit](https://www.ncbi.nlm.nih.gov/books/NBK158900/) but this is rather slow too:  
```{bash, eval=FALSE}
wget ftp://ftp.sra.ebi.ac.uk/vol1/srr/SRR208/008/SRR2084598
fastq-dump SRR2084598
```
  
A very nice tutorial on how to download such large files faster is available [here](https://www.biostars.org/p/325010/).  
  
First install the [Aspera client](http://www.asperasoft.com/en/downloads/2).  
  
Then go to the [EBI ENA](https://www.ebi.ac.uk/ena) and search for `GSE70408`  
In the experiment page, select columns:
 __Study accession__,
 __Library Layout__,
 __FASTQ files (FTP)__ and
 __Experiment title__
and export the table as text.  

Now we use [R](https://www.r-project.org/) to extract the files we want and prepare the links for fast download:
```{r, eval=FALSE}
#All the files:
gse70408 <- read.table(file.path("../data","PRJNA288695.txt"), 
                       sep="\t", header=T)

#Selected files:
selgse70408 <- gse70408[c(
                    grep("total.RNA", gse70408[,2]),
                    grep("PAF1_WT", gse70408[,2])),]

#Format the links for aspera client:
selgse70408$fasp_link <- gsub("ftp.sra.ebi.ac.uk",
                              "era-fasp@fasp.sra.ebi.ac.uk:",
                              selgse70408$fastq_ftp)

#save the links
write.table(selgse70408$fasp_link,
            file.path("../data/downloadSelectedGSE70408.txt"),
            row.names = FALSE, col.names = FALSE, quote = FALSE)
```

Then download all the selected files using:
```{bash eval=FALSE}
cat downloadSelectedGSE70408.txt | while read LIST
  do
  $HOME/.aspera/connect/bin/ascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh $LIST .
  done
```

I have then filtered these fastq files to keep only reads mapping to chromosomes 19 and 20 (plus ~5% of unmapped reads to make it more realistic `r emo::ji("wink")`). The filtered reads are in the data folder.


## RNA-seq


### Raw reads - QC - Trimming

#### QC
Quality controls on raw reads can be done with [fastqc](https://www.bioinformatics.babraham.ac.uk/projects/fastqc/).  
More advanced QC can also be performed using e.g. [RSeQC](http://rseqc.sourceforge.net/).  
Note that in RNA-seq (and other applications as well) it is often desirable to compare the QC obtained from different samples. [MultiQC](https://multiqc.info/) is an excellent tool to facilite this task.

```{bash, eval=FALSE}
mkdir ${basedir}/RNAseq/rawQC
module load bioinfo/FastQC_v0.11.7 #on genologin cluster

for fn in SRR20845{96..99}
  do

  fastqc \
    -o ${basedir}/RNAseq/rawQC \
    ${basedir}/data/FilteredFastq/${fn}_chr1920.fq.gz \
    
  done
```
  
  

#### Trimming  

In many cases RNA-seq reads do not require trimming. If you notice a lot of adapter contamination, you can use [cutadapt](https://cutadapt.readthedocs.io/en/stable/guide.html) or [Trimmomatic](http://www.usadellab.org/cms/?page=trimmomatic) for example.  
  
Note that [fastp](https://github.com/OpenGene/fastp), a recently developed tool integrates automatic trimming (and adapter detection) with pre- and post-filtering QC [@doi:10.1093/bioinformatics/bty560].  
  
  

### Alignment

Align the reads to the "genome" (here only chr19 and chr20) using STAR:
```{bash eval=FALSE}
mkdir ${basedir}/RNAseq/Aligned
module load bioinfo/STAR-2.6.0c #on genologin cluster

fastqdir=${basedir}/data/filteredFastq

for fn in SRR208459{6..9}
do

    STAR \
        --runMode alignReads \
        --runThreadN 4 \
        --genomeDir ${basedir}/bank/star_index \
        --readFilesIn ${fastqdir}/${fn}_chr1920.fq.gz\
        --readFilesCommand zcat \
        --outFileNamePrefix ${basedir}/RNAseq/Aligned/${fn}_chr1920_ \
        --outSAMtype BAM SortedByCoordinate \
        --quantMode TranscriptomeSAM GeneCounts \
        --outWigType bedGraph \

done

```
The option `--quantmode TranscriptomeSAM` produces the alignments in the coordinates of the transcriptome.  
The option `--quantmode GeneCounts` produces a table with counts of reads per gene.  
The option `--outWigType bedGraph` produces bedgraph files that can be used to vizualize the data in a genome browser.  



### Counting and differential expression analysis

In addition to STAR (see above), there are several other options to count reads (including splice reads) on genomic features such as genes. An early and still popular solution with python is [HTseq](https://github.com/simon-anders/htseq). Another efficient tool is [featureCounts](http://subread.sourceforge.net/) that is also accessible in R via the [Rsubread](http://bioconductor.org/packages/release/bioc/html/Rsubread.html) package.  

Although less memory efficient, it is also possible to use the `summarizeOverlaps` function of the [GenomicAlignments](http://bioconductor.org/packages/release/bioc/html/GenomicAlignments.html) package from Bioconductor:
```{r, eval=FALSE, message=FALSE, warning=FALSE}
#module load system/R-3.4.3 #on genologin cluster (choose the right version for you)
library(GenomicAlignments)
#Prepare the annotations:
library(TxDb.Hsapiens.UCSC.hg38.knownGene)
txdb <- GenomeInfoDb::keepSeqlevels(TxDb.Hsapiens.UCSC.hg38.knownGene,
                                    c("chr19", "chr20"),
                                    pruning.mode = "coarse")
hg38exBygn <- exonsBy(txdb, by="gene")

# Bam files:
bampath <- "/work/pmartin/PROJECTS/RNAseqChIPseq/RNAseq/Aligned"
bamfn <- BamFileList(dir(bampath, pattern="*.sortedByCoord.out.bam$", full=TRUE))

ct <- summarizeOverlaps(hg38exBygn,
                        bamfn,
                        mode = "Union",
                        singleEnd=TRUE,
                        ignore.strand = TRUE)
colnames(ct) <- paste0("SRR208459",6:9)
```

```{r, eval=FALSE, include=FALSE}
saveRDS(head(assays(ct)$counts), "data/headct.rds")
```

The counts are obtained using:
```{r, eval=FALSE}
head(assays(ct)$counts)
```

```{r, echo=FALSE}
headct <- readRDS("../data/headct.rds")
headct %>%
    kable() %>%
    kable_styling(font_size = 13,
                  bootstrap_options = c("striped", "condensed"),
                  full_width = FALSE)
```

The percentage of reads from the BAM files that were assigned to a gene model can be obtained with:
```{r, eval=FALSE}
100 * colSums(assays(ct)$counts) / countBam(bamfn)$records
# ~76-80%
```

Using these counts, we can perform a differential expression analysis using e.g. [DESeq2](http://bioconductor.org/packages/release/bioc/html/DESeq2.html).  
For this, we first prepare the data:
```{r, eval=FALSE, message=FALSE, warning=FALSE}
library(DESeq2)
colData <- DataFrame(SampleName = colnames(ct),
                     condition = factor(rep(c("shPAF1","Ctrol"), each=2)),
                     row.names = colnames(ct))

dds <- DESeqDataSetFromMatrix(countData = assays(ct)$counts,
                              colData = colData,
                              design = ~ condition)
```

Then, we remove the genes that have 0 counts for all samples. We can add other filters here, such as keeping only protein-coding genes or removing genes overlapping with a _blacklist_.
```{r, eval=FALSE}
dds <- dds[rowSums(assay(dds))!=0,]
```

And we perform the analysis:
```{r, eval=FALSE, message=FALSE}
dds <- DESeq(dds)
```
```{r, eval=FALSE, include=FALSE}
saveRDS(results(dds), "data/ddsres.rds")
```


We get the number of DE genes (at FDR=5%) using:
```{r, eval=FALSE}
sum(results(dds)$padj<0.05, na.rm = TRUE)
```
```{r, echo=FALSE, message=FALSE, warning=FALSE}
ddsres <- readRDS("../data/ddsres.rds")
sum(ddsres$padj<0.05, na.rm=TRUE)
```


The results table can be vizualized using:
```{r, eval=FALSE}
head(results(dds))
```

```{r, echo=FALSE}
head(ddsres) %>%
    kable(digits=c(2,2,3,3,6,6)) %>%
    kable_styling(font_size = 13,
                  bootstrap_options = c("striped", "condensed"),
                  full_width = FALSE)
```

The DE genes can now be further studied (e.g. enrichment of GO annotations or specific pathwyas?) and integrated with other measurements (e.g. ChIP-seq)

```{r, eval=FALSE, include=FALSE}
## Compare summarizeOverlaps with STAR counting:
gnct <- lapply(dir(pattern="_ReadsPerGene.out.tab"), read.table, sep="\t")
ctstar <- do.call("cbind", lapply(gnct, `[`, -(1:4), 2))
  rownames(ctstar) <- gsub("\\..+", "", gnct[[1]][-(1:4),1])
  colnames(ctstar) <- paste0("SRR208459",6:9)

  #Problem, the names don't match
library(org.Hs.eg.db)
eg2ens <- select(org.Hs.eg.db, keytype="ENTREZID", column="ENSEMBL", key=rownames(ct))
#There are 40 Entrez gene that match with 2 ensembl genes (also because Ensembl database version is different between star counting and org package)
#let's keep only the single match (also for Ensembl):
egdup <- eg2ens[duplicated(eg2ens[,"ENTREZID"]),"ENTREZID"]
eg2ens <- eg2ens[!(eg2ens[,"ENTREZID"] %in% egdup),]
ensdup <- eg2ens[duplicated(eg2ens[,"ENSEMBL"]),"ENSEMBL"]
eg2ens <- eg2ens[!(eg2ens[,"ENSEMBL"] %in% ensdup), ]
eg2ens <- eg2ens[eg2ens[,"ENSEMBL"] %in% rownames(ctstar), ]

#get non ambiguous count tables
ctstarOK <- ctstar[eg2ens[,"ENSEMBL"],]
ctOK <- ct[eg2ens[,"ENTREZID"],]

par(mfrow=c(2,2))
for (i in 1:4) { plot(log2(ctstarOK[,i]+1), log2(assays(ctOK)$count[,i]+1)) }
#OK counts are really close. I should use the exact same annotation to do this comparison
```


### Obtaining expression levels

While **counts** are the preferred measure to perform differential expression analysis, they also depend on transcript size. For 2 equally abundant transcripts, if one is twice the length of the other, then reads from the longer transcript are twice more likely to be sequenced.  
So in order to compare the expression of different genes, we need to normalize by gene/transcript size. This raises questions such as:  

- If a gene produces different transcripts that share exons, and the counts are at the gene level, which size should we use?  
- If a gene produces different transcripts in different samples (because e.g. splicing or initiation/termination of transcription have been affected by an experimental condition), then we can't use the same size to normalize the data.  

Because of such issues (and because of the stochasticity in the data), we can only estimate the actual gene expression levels and can't reliably tell if 2 genes with very close expression measures are actually expressed at different levels. We can nevertheless form groups of genes that faithfully represent e.g. low, moderate or high expression levels.  
  
The first, very intuitive measure that was proposed is the **RPKM** (or **FPKM** if applied at the level of fragments from paired-end sequencing) in which the number of reads is normalized by gene length (_reads per kilobase_) and then by the library size (_reads per million_).

Later it was shown that one limitation of RPKM/FPKM was that their sum was different between samples and experiment (**REF**) and the **TPM** (Transcript per million) was introduced. The principle of the normalization is globally the same but the order in which the normalization are performed differs.


More recently, it was realized that classical spliced-read alignment on the genome was not a necessity to evaluate where the reads were coming from. => Salmon/Kallisto approach using pseudo-alignment / kmers to assess abundances at the isoform level

TODO: *Add the math*
TODO: *examples of RPKM and TPM in R*
TODO: *example of TPM with RSEM*
TODO: *example with Salmon*
TODO: *Provide some refs of discussions on this topic*


### Signal files for genome browser
_"Signal files"_ contain some kind of counting (possibly normalized by library size) of the number of reads that are aligned at each position of the genome. They are generally in [wig](https://genome.ucsc.edu/goldenpath/help/wiggle.html) / [bigwig](https://genome.ucsc.edu/goldenpath/help/bigWig.html) format or in [bedgraph](https://genome.ucsc.edu/goldenpath/help/bedgraph.html) format.  
We have already obtained these files above via the STAR command (see [Alignment]). We can also obtain such files using the `coverage` function in R:

```{r, eval=FALSE}
mybam <- readGAlignments(file.path(bampath, 
                                   "SRR2084596_chr1920_Aligned.sortedByCoord.out.bam"))
# !! for RNA-seq do not convert the reads to granges because spliced reads would results in coverage on the introns
covbam <- coverage(grglist(mybam))
#At this step it is generally necessary to normalize
rtracklayer(export(covbam), "myProfile.bigwig")
```

The [rtracklayer](http://bioconductor.org/packages/release/bioc/html/rtracklayer.html) package is also very useful to import different profiles and perform operations on them (e.g. calculate averages, differences or ratios of profiles). 
All these signal files can then be vizualized on a genome browser.

  
## ChIP-seq

### Raw reads - QC - Trimming

[fastqc](https://www.bioinformatics.babraham.ac.uk/projects/fastqc/)
distribution of fragment length (paired end)

### Alignment and profiles

bwa or bowtie2

### Peak calling

MACS, SICER, etc.

### Peak annotation

ChIPpeakanno

### Extracting profiles around genomic features

Average profiles and heatmaps
genomation
EnrichedHeatmap

### Extracting sequences for motif search

Biostrings
=> RSAT, MEME, etc.



### References:  

